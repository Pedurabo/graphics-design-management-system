<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fundamental Graphics Application</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f0f0;
            color: #333;
            overflow: hidden;
            height: 100vh;
        }

        /* Standard Application Layout */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Menu Bar - Standard Office Application Pattern */
        .menu-bar {
            background: #2b579a;
            color: white;
            padding: 4px 8px;
            display: flex;
            align-items: center;
            font-size: 12px;
            border-bottom: 1px solid #1e3a8a;
        }

        .menu-item {
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            position: relative;
        }

        .menu-item:hover {
            background: #1e3a8a;
        }

        .menu-item:active {
            background: #1e40af;
        }

        /* Dropdown Menu */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background: white;
            min-width: 160px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            z-index: 1000;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        .dropdown-item {
            color: #333;
            padding: 8px 12px;
            text-decoration: none;
            display: block;
            font-size: 12px;
            border-bottom: 1px solid #eee;
        }

        .dropdown-item:hover {
            background: #f0f0f0;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        /* Toolbar - Standard Office Pattern */
        .toolbar {
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tool-group {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-right: 1px solid #dee2e6;
        }

        .tool-group:last-child {
            border-right: none;
        }

        .tool-button {
            background: white;
            border: 1px solid #dee2e6;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s ease;
            position: relative;
        }

        .tool-button:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .tool-button:active {
            background: #dee2e6;
        }

        .tool-button.active {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .tool-button:hover .tooltip {
            opacity: 1;
        }

        /* Main Content Area */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar - Standard Office Pattern */
        .sidebar {
            width: 250px;
            background: white;
            border-right: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
        }

        .sidebar-section {
            border-bottom: 1px solid #dee2e6;
        }

        .sidebar-header {
            background: #f8f9fa;
            padding: 8px 12px;
            font-weight: bold;
            font-size: 12px;
            color: #495057;
            border-bottom: 1px solid #dee2e6;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header:hover {
            background: #e9ecef;
        }

        .sidebar-content {
            padding: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .sidebar-item {
            padding: 6px 8px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            margin-bottom: 2px;
        }

        .sidebar-item:hover {
            background: #f8f9fa;
        }

        .sidebar-item.active {
            background: #007bff;
            color: white;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            background: #e9ecef;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .canvas-toolbar {
            background: white;
            border-bottom: 1px solid #dee2e6;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 12px;
        }

        .canvas {
            flex: 1;
            background: white;
            margin: 16px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: crosshair;
        }

        /* Status Bar - Standard Office Pattern */
        .status-bar {
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            padding: 4px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            color: #6c757d;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            min-width: 150px;
        }

        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            border-bottom: 1px solid #f8f9fa;
        }

        .context-menu-item:hover {
            background: #f8f9fa;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        /* Dialog/Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            width: 400px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid #dee2e6;
        }

        .modal-title {
            font-weight: bold;
            font-size: 16px;
        }

        .close {
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
        }

        .close:hover {
            color: #dc3545;
        }

        .modal-body {
            margin-bottom: 16px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            background: white;
        }

        .btn:hover {
            background: #f8f9fa;
        }

        .btn-primary {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        /* Form Controls */
        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .form-control {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 12px;
        }

        .form-control:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }

        /* Color Picker */
        .color-picker {
            width: 100%;
            height: 40px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Slider */
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #dee2e6;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: none;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1001;
            display: none;
            font-size: 12px;
        }

        /* Keyboard Shortcuts Display */
        .shortcuts-panel {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 12px;
            margin-top: 8px;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 11px;
        }

        .shortcut-key {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Menu Bar -->
        <div class="menu-bar">
            <div class="dropdown">
                <div class="menu-item">File</div>
                <div class="dropdown-content">
                    <div class="dropdown-item" onclick="showModal('newFileModal')">New (Ctrl+N)</div>
                    <div class="dropdown-item" onclick="openFile()">Open... (Ctrl+O)</div>
                    <div class="dropdown-item" onclick="saveFile()">Save (Ctrl+S)</div>
                    <div class="dropdown-item" onclick="saveAsFile()">Save As... (Ctrl+Shift+S)</div>
                    <div class="dropdown-item" style="border-top: 1px solid #dee2e6;">Export</div>
                    <div class="dropdown-item" onclick="exportPNG()">Export as PNG</div>
                    <div class="dropdown-item" onclick="exportJPG()">Export as JPG</div>
                    <div class="dropdown-item" onclick="exportPDF()">Export as PDF</div>
                    <div class="dropdown-item" style="border-top: 1px solid #dee2e6;">Exit</div>
                </div>
            </div>
            <div class="dropdown">
                <div class="menu-item">Edit</div>
                <div class="dropdown-content">
                    <div class="dropdown-item" onclick="undo()">Undo (Ctrl+Z)</div>
                    <div class="dropdown-item" onclick="redo()">Redo (Ctrl+Y)</div>
                    <div class="dropdown-item" style="border-top: 1px solid #dee2e6;">Cut (Ctrl+X)</div>
                    <div class="dropdown-item">Copy (Ctrl+C)</div>
                    <div class="dropdown-item">Paste (Ctrl+V)</div>
                    <div class="dropdown-item" style="border-top: 1px solid #dee2e6;">Select All (Ctrl+A)</div>
                    <div class="dropdown-item">Clear Selection (Ctrl+D)</div>
                </div>
            </div>
            <div class="dropdown">
                <div class="menu-item">View</div>
                <div class="dropdown-content">
                    <div class="dropdown-item" onclick="zoomIn()">Zoom In (Ctrl++)</div>
                    <div class="dropdown-item" onclick="zoomOut()">Zoom Out (Ctrl+-)</div>
                    <div class="dropdown-item" onclick="zoomFit()">Fit to Screen (Ctrl+0)</div>
                    <div class="dropdown-item" style="border-top: 1px solid #dee2e6;">Show Grid (Ctrl+G)</div>
                    <div class="dropdown-item">Show Rulers (Ctrl+R)</div>
                    <div class="dropdown-item">Show Guides</div>
                </div>
            </div>
            <div class="dropdown">
                <div class="menu-item">Tools</div>
                <div class="dropdown-content">
                    <div class="dropdown-item" onclick="selectTool('select')">Selection Tool (V)</div>
                    <div class="dropdown-item" onclick="selectTool('brush')">Brush Tool (B)</div>
                    <div class="dropdown-item" onclick="selectTool('eraser')">Eraser Tool (E)</div>
                    <div class="dropdown-item" onclick="selectTool('text')">Text Tool (T)</div>
                    <div class="dropdown-item" onclick="selectTool('shape')">Shape Tool (U)</div>
                    <div class="dropdown-item" onclick="selectTool('eyedropper')">Eyedropper (I)</div>
                    <div class="dropdown-item" onclick="selectTool('smartSelection')">Smart Selection (W)</div>
                    <div class="dropdown-item" onclick="selectTool('objectDetection')">Object Detection (O)</div>
                    <div class="dropdown-item" onclick="selectTool('qualityAnalysis')">Quality Analysis (Q)</div>
                    <div class="dropdown-item" onclick="selectTool('faceDetection')">Face Detection (F)</div>
                    <div class="dropdown-item" onclick="selectTool('emotionRecognition')">Emotion Recognition (E)</div>
                    <div class="dropdown-item" onclick="selectTool('portraitEnhancement')">Portrait Enhancement (P)</div>
                </div>
            </div>
            <div class="dropdown">
                <div class="menu-item">Help</div>
                <div class="dropdown-content">
                    <div class="dropdown-item" onclick="showHelp()">Help (F1)</div>
                    <div class="dropdown-item" onclick="showShortcuts()">Keyboard Shortcuts</div>
                    <div class="dropdown-item" onclick="showAbout()">About</div>
                </div>
            </div>
        </div>

        <!-- Toolbar -->
        <div class="toolbar">
            <div class="tool-group">
                <button class="tool-button" onclick="newFile()" title="New File (Ctrl+N)">
                    üìÑ New
                </button>
                <button class="tool-button" onclick="openFile()" title="Open File (Ctrl+O)">
                    üìÅ Open
                </button>
                <button class="tool-button" onclick="saveFile()" title="Save (Ctrl+S)">
                    üíæ Save
                </button>
            </div>
            
            <div class="tool-group">
                <button class="tool-button" onclick="undo()" title="Undo (Ctrl+Z)">
                    ‚Ü©Ô∏è Undo
                </button>
                <button class="tool-button" onclick="redo()" title="Redo (Ctrl+Y)">
                    ‚Ü™Ô∏è Redo
                </button>
            </div>
            
            <div class="tool-group">
                <button class="tool-button active" id="selectTool" onclick="selectTool('select')" title="Selection Tool (V)">
                    üëÜ Select
                </button>
                <button class="tool-button" id="moveTool" onclick="selectTool('move')" title="Move Tool (V)">
                    ‚úã Move
                </button>
                <button class="tool-button" id="cropTool" onclick="selectTool('crop')" title="Crop Tool (C)">
                    ‚úÇÔ∏è Crop
                </button>
            </div>
            
            <div class="tool-group">
                <button class="tool-button" id="brushTool" onclick="selectTool('brush')" title="Brush Tool (B)">
                    üñåÔ∏è Brush
                </button>
                <button class="tool-button" id="eraserTool" onclick="selectTool('eraser')" title="Eraser Tool (E)">
                    üßΩ Eraser
                </button>
                <button class="tool-button" id="cloneTool" onclick="selectTool('clone')" title="Clone Stamp Tool (S)">
                    üñ≤Ô∏è Clone
                </button>
                <button class="tool-button" id="healingTool" onclick="selectTool('healing')" title="Healing Tool (J)">
                    ü©π Healing
                </button>
            </div>
            
            <div class="tool-group">
                <button class="tool-button" id="gradientTool" onclick="selectTool('gradient')" title="Gradient Tool (G)">
                    üåà Gradient
                </button>
                <button class="tool-button" id="shapeTool" onclick="selectTool('shape')" title="Shape Tool (U)">
                    ‚¨ú Shape
                </button>
                <button class="tool-button" id="penTool" onclick="selectTool('pen')" title="Pen Tool (P)">
                    ‚úíÔ∏è Pen
                </button>
                <button class="tool-button" id="textTool" onclick="selectTool('text')" title="Text Tool (T)">
                    T Text
                </button>
            </div>
            
            <div class="tool-group">
                <button class="tool-button" id="eyedropperTool" onclick="selectTool('eyedropper')" title="Eyedropper Tool (I)">
                    üé® Eyedropper
                </button>
                <button class="tool-button" id="handTool" onclick="selectTool('hand')" title="Hand Tool (H)">
                    ü§ö Hand
                </button>
                <button class="tool-button" id="zoomTool" onclick="selectTool('zoom')" title="Zoom Tool (Z)">
                    üîç Zoom
                </button>
            </div>
            
            <div class="tool-group">
                <button class="tool-button" id="smartSelectionTool" onclick="selectTool('smartSelection')" title="Smart Selection Tool (W)">
                    üß† Smart Select
                </button>
                <button class="tool-button" id="objectDetectionTool" onclick="selectTool('objectDetection')" title="Object Detection (O)">
                    üîç Object Detect
                </button>
                <button class="tool-button" id="qualityAnalysisTool" onclick="selectTool('qualityAnalysis')" title="Quality Analysis (Q)">
                    üìä Quality
                </button>
            </div>
            
            <div class="tool-group">
                <button class="tool-button" id="faceDetectionTool" onclick="selectTool('faceDetection')" title="Face Detection (F)">
                    üë§ Face Detect
                </button>
                <button class="tool-button" id="emotionRecognitionTool" onclick="selectTool('emotionRecognition')" title="Emotion Recognition (E)">
                    üòä Emotion
                </button>
                <button class="tool-button" id="portraitEnhancementTool" onclick="selectTool('portraitEnhancement')" title="Portrait Enhancement (P)">
                    ‚ú® Portrait
                </button>
            </div>
            
            <div class="tool-group">
                <label style="font-size: 11px; margin-right: 4px;">Color:</label>
                <input type="color" id="colorPicker" class="color-picker" value="#000000" onchange="updateColor()">
            </div>
            
            <div class="tool-group">
                <label style="font-size: 11px; margin-right: 4px;">Size:</label>
                <input type="range" id="sizeSlider" class="slider" min="1" max="100" value="5" onchange="updateSize()">
                <span id="sizeValue" style="font-size: 11px; min-width: 20px;">5</span>
            </div>
            
            <div class="tool-group">
                <label style="font-size: 11px; margin-right: 4px;">Opacity:</label>
                <input type="range" id="opacitySlider" class="slider" min="1" max="100" value="100" onchange="updateOpacity()">
                <span id="opacityValue" style="font-size: 11px; min-width: 30px;">100%</span>
            </div>
            
            <div class="tool-group">
                <label style="font-size: 11px; margin-right: 4px;">Flow:</label>
                <input type="range" id="flowSlider" class="slider" min="1" max="100" value="100" onchange="updateFlow()">
                <span id="flowValue" style="font-size: 11px; min-width: 30px;">100%</span>
            </div>
            
            <div class="tool-group">
                <button class="tool-button" onclick="testFunctionality()" title="Test Functionality">
                    üß™ Test
                </button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Sidebar -->
            <div class="sidebar">
                <div class="sidebar-section">
                    <div class="sidebar-header" onclick="toggleSection('layers')">
                        Layers
                        <span id="layers-toggle">‚ñº</span>
                    </div>
                    <div class="sidebar-content" id="layers-content">
                        <div class="sidebar-item active">Background</div>
                        <div class="sidebar-item">Layer 1</div>
                        <div class="sidebar-item">Layer 2</div>
                    </div>
                    <div style="padding: 8px; border-top: 1px solid #dee2e6;">
                        <button class="btn" onclick="createNewLayer()" style="width: 100%; margin-bottom: 4px;">‚ûï New Layer</button>
                        <button class="btn" onclick="duplicateLayer()" style="width: 100%; margin-bottom: 4px;">üìã Duplicate</button>
                        <button class="btn" onclick="deleteLayer()" style="width: 100%;">üóëÔ∏è Delete</button>
                    </div>
                </div>
                
                <div class="sidebar-section">
                    <div class="sidebar-header" onclick="toggleSection('properties')">
                        Properties
                        <span id="properties-toggle">‚ñº</span>
                    </div>
                    <div class="sidebar-content" id="properties-content">
                        <div class="form-group">
                            <label class="form-label">Opacity</label>
                            <input type="range" class="slider" min="0" max="100" value="100" onchange="updateLayerOpacity(this.value)">
                            <span id="opacityValue">100%</span>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Blend Mode</label>
                            <select class="form-control" onchange="updateBlendMode(this.value)">
                                <option value="normal">Normal</option>
                                <option value="multiply">Multiply</option>
                                <option value="screen">Screen</option>
                                <option value="overlay">Overlay</option>
                                <option value="soft-light">Soft Light</option>
                                <option value="hard-light">Hard Light</option>
                                <option value="color-dodge">Color Dodge</option>
                                <option value="color-burn">Color Burn</option>
                                <option value="darken">Darken</option>
                                <option value="lighten">Lighten</option>
                                <option value="difference">Difference</option>
                                <option value="exclusion">Exclusion</option>
                                <option value="hue">Hue</option>
                                <option value="saturation">Saturation</option>
                                <option value="color">Color</option>
                                <option value="luminosity">Luminosity</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Lock</label>
                            <button class="btn" onclick="toggleLayerLock()">üîí Lock</button>
                        </div>
                    </div>
                </div>
                
                <div class="sidebar-section">
                    <div class="sidebar-header" onclick="toggleSection('adjustments')">
                        Adjustments
                        <span id="adjustments-toggle">‚ñº</span>
                    </div>
                    <div class="sidebar-content" id="adjustments-content">
                        <button class="btn" onclick="addAdjustment('brightness')">Brightness/Contrast</button>
                        <button class="btn" onclick="addAdjustment('levels')">Levels</button>
                        <button class="btn" onclick="addAdjustment('curves')">Curves</button>
                        <button class="btn" onclick="addAdjustment('hue')">Hue/Saturation</button>
                        <button class="btn" onclick="addAdjustment('color-balance')">Color Balance</button>
                        <button class="btn" onclick="addAdjustment('black-white')">Black & White</button>
                    </div>
                </div>
                
                <div class="sidebar-section">
                    <div class="sidebar-header" onclick="toggleSection('filters')">
                        Filters
                        <span id="filters-toggle">‚ñº</span>
                    </div>
                    <div class="sidebar-content" id="filters-content">
                        <button class="btn" onclick="applyFilter('blur')">Blur</button>
                        <button class="btn" onclick="applyFilter('sharpen')">Sharpen</button>
                        <button class="btn" onclick="applyFilter('noise')">Noise</button>
                        <button class="btn" onclick="applyFilter('emboss')">Emboss</button>
                        <button class="btn" onclick="applyFilter('edge')">Find Edges</button>
                        <button class="btn" onclick="applyFilter('invert')">Invert</button>
                    </div>
                </div>
                
                <div class="sidebar-section">
                    <div class="sidebar-header" onclick="toggleSection('history')">
                        History
                        <span id="history-toggle">‚ñº</span>
                    </div>
                    <div class="sidebar-content" id="history-content">
                        <div class="sidebar-item">New Document</div>
                        <div class="sidebar-item">Brush Stroke</div>
                        <div class="sidebar-item">Color Change</div>
                    </div>
                </div>
            </div>

            <!-- Canvas Area -->
            <div class="canvas-container">
                <div class="canvas-toolbar">
                    <span>Tool: <span id="currentTool">Select</span></span>
                    <span>Position: <span id="mousePosition">0, 0</span></span>
                    <span>Zoom: <span id="zoomLevel">100%</span></span>
                    <span>Size: <span id="toolSize">5px</span></span>
                </div>
                <canvas id="canvas" class="canvas" width="800" height="600"></canvas>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <span>Ready</span>
            </div>
            <div class="status-item">
                <span>Document: 800x600px</span>
            </div>
            <div class="status-item">
                <span>Memory: 2.3MB</span>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="cut()">Cut</div>
        <div class="context-menu-item" onclick="copy()">Copy</div>
        <div class="context-menu-item" onclick="paste()">Paste</div>
        <div class="context-menu-item" style="border-top: 1px solid #dee2e6;">Delete</div>
        <div class="context-menu-item" style="border-top: 1px solid #dee2e6;">Select All</div>
        <div class="context-menu-item">Properties...</div>
    </div>

    <!-- New File Modal -->
    <div class="modal" id="newFileModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">New Document</div>
                <div class="close" onclick="closeModal('newFileModal')">&times;</div>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Width (px)</label>
                    <input type="number" class="form-control" id="newWidth" value="800" min="1" max="4000">
                </div>
                <div class="form-group">
                    <label class="form-label">Height (px)</label>
                    <input type="number" class="form-control" id="newHeight" value="600" min="1" max="4000">
                </div>
                <div class="form-group">
                    <label class="form-label">Background Color</label>
                    <input type="color" class="form-control" id="newBgColor" value="#ffffff">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('newFileModal')">Cancel</button>
                <button class="btn btn-primary" onclick="createNewFile()">Create</button>
            </div>
        </div>
    </div>

    <!-- Keyboard Shortcuts Modal -->
    <div class="modal" id="shortcutsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Keyboard Shortcuts</div>
                <div class="close" onclick="closeModal('shortcutsModal')">&times;</div>
            </div>
            <div class="modal-body">
                <div class="shortcuts-panel">
                    <div class="shortcut-item">
                        <span>New File</span>
                        <span class="shortcut-key">Ctrl+N</span>
                    </div>
                    <div class="shortcut-item">
                        <span>Open File</span>
                        <span class="shortcut-key">Ctrl+O</span>
                    </div>
                    <div class="shortcut-item">
                        <span>Save</span>
                        <span class="shortcut-key">Ctrl+S</span>
                    </div>
                    <div class="shortcut-item">
                        <span>Undo</span>
                        <span class="shortcut-key">Ctrl+Z</span>
                    </div>
                    <div class="shortcut-item">
                        <span>Redo</span>
                        <span class="shortcut-key">Ctrl+Y</span>
                    </div>
                    <div class="shortcut-item">
                        <span>Select Tool</span>
                        <span class="shortcut-key">V</span>
                    </div>
                    <div class="shortcut-item">
                        <span>Brush Tool</span>
                        <span class="shortcut-key">B</span>
                    </div>
                    <div class="shortcut-item">
                        <span>Eraser Tool</span>
                        <span class="shortcut-key">E</span>
                    </div>
                    <div class="shortcut-item">
                        <span>Text Tool</span>
                        <span class="shortcut-key">T</span>
                    </div>
                    <div class="shortcut-item">
                        <span>Zoom In</span>
                        <span class="shortcut-key">Ctrl++</span>
                    </div>
                    <div class="shortcut-item">
                        <span>Zoom Out</span>
                        <span class="shortcut-key">Ctrl+-</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="closeModal('shortcutsModal')">Close</button>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <script>
        // Advanced Photoshop-Level Graphics Application
        class AdvancedGraphicsApp {
            constructor() {
                this.canvas = document.getElementById('canvas');
                if (!this.canvas) {
                    console.error('Canvas element not found');
                    return;
                }
                
                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) {
                    console.error('Canvas context not available');
                    return;
                }
                
                this.currentTool = 'select';
                this.isDrawing = false;
                this.history = [];
                this.historyIndex = -1;
                this.zoom = 1;
                this.offsetX = 0;
                this.offsetY = 0;
                
                // Advanced Photoshop Features
                this.layers = [];
                this.activeLayer = null;
                this.selection = null;
                this.foregroundColor = '#000000';
                this.backgroundColor = '#ffffff';
                this.brushSize = 5;
                this.brushOpacity = 100;
                this.brushFlow = 100;
                this.blendMode = 'source-over';
                this.toolSettings = {};
                this.smartObjects = [];
                this.adjustments = [];
                this.filters = [];
                this.actions = [];
                this.workspace = 'photography';
                this.theme = 'dark';
                
                        // AI Features - Enhanced with Rice MSC Dataset methodology
        this.aiEnabled = true;
        this.generativeFill = true;
        this.contentAware = true;
        this.smartSelection = true;
        this.featureExtraction = true;
        this.objectDetection = true;
        this.qualityAnalysis = true;
        
        // Rice MSC Dataset inspired features
        this.mostEffectiveFeatures = ['roundness', 'compactness', 'shape_factor_3', 'aspect_ratio', 'eccentricity'];
        this.colorSpaces = ['RGB', 'HSV', 'Lab*', 'YCbCr', 'XYZ'];
        this.featureCount = 106; // 12 morphological + 4 shape + 90 color features
                
                this.initializeCanvas();
                this.setupLayers();
                this.setupEventListeners();
                this.setupAdvancedTools();
                this.saveState();
            }

            initializeCanvas() {
                if (!this.canvas || !this.ctx) {
                    console.error('Canvas or context not available');
                    return;
                }
                
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                
                // Enable advanced canvas features
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.globalAlpha = 1.0;
                
                console.log('Canvas initialized successfully');
            }
            
            setupLayers() {
                // Create background layer
                this.layers = [{
                    id: 'background',
                    name: 'Background',
                    visible: true,
                    locked: false,
                    opacity: 100,
                    blendMode: 'normal',
                    canvas: document.createElement('canvas'),
                    type: 'background'
                }];
                
                this.activeLayer = this.layers[0];
                this.activeLayer.canvas.width = this.canvas.width;
                this.activeLayer.canvas.height = this.canvas.height;
                this.activeLayer.ctx = this.activeLayer.canvas.getContext('2d');
                this.activeLayer.ctx.fillStyle = '#ffffff';
                this.activeLayer.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.updateLayersPanel();
            }
            
            setupAdvancedTools() {
                // Initialize advanced tool settings
                this.toolSettings = {
                    brush: {
                        size: 5,
                        opacity: 100,
                        flow: 100,
                        hardness: 50,
                        spacing: 25,
                        shape: 'round',
                        dynamics: {
                            size: false,
                            opacity: false,
                            flow: false
                        }
                    },
                    eraser: {
                        size: 5,
                        opacity: 100,
                        hardness: 50
                    },
                    selection: {
                        feather: 0,
                        antiAlias: true
                    },
                    clone: {
                        size: 5,
                        opacity: 100,
                        alignment: true,
                        sample: 'current'
                    },
                    healing: {
                        size: 5,
                        type: 'spot', // spot, healing, patch
                        contentAware: true
                    }
                };
            }

            setupEventListeners() {
                if (!this.canvas) {
                    console.error('Canvas not available for event listeners');
                    return;
                }
                
                // Mouse events
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('contextmenu', this.handleContextMenu.bind(this));
                
                // Keyboard events
                document.addEventListener('keydown', this.handleKeyboard.bind(this));
                
                // Window events
                window.addEventListener('resize', this.handleResize.bind(this));
                
                console.log('Event listeners set up successfully');
            }

            handleMouseDown(e) {
                this.isDrawing = true;
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / this.zoom;
                const y = (e.clientY - rect.top) / this.zoom;
                
                this.startX = x;
                this.startY = y;
                
                this.executeTool(this.currentTool, x, y, 'start');
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / this.zoom;
                const y = (e.clientY - rect.top) / this.zoom;
                
                document.getElementById('mousePosition').textContent = `${Math.round(x)}, ${Math.round(y)}`;
                
                if (this.isDrawing) {
                    this.executeTool(this.currentTool, x, y, 'move');
                }
            }

            handleMouseUp(e) {
                this.isDrawing = false;
                this.saveState();
            }

            handleContextMenu(e) {
                e.preventDefault();
                const contextMenu = document.getElementById('contextMenu');
                contextMenu.style.display = 'block';
                contextMenu.style.left = e.clientX + 'px';
                contextMenu.style.top = e.clientY + 'px';
                
                // Hide context menu when clicking elsewhere
                setTimeout(() => {
                    document.addEventListener('click', hideContextMenu);
                }, 100);
            }

            handleKeyboard(e) {
                // Standard keyboard shortcuts
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 'n':
                            e.preventDefault();
                            this.newFile();
                            break;
                        case 'o':
                            e.preventDefault();
                            this.openFile();
                            break;
                        case 's':
                            e.preventDefault();
                            if (e.shiftKey) {
                                this.saveAsFile();
                            } else {
                                this.saveFile();
                            }
                            break;
                        case 'z':
                            e.preventDefault();
                            this.undo();
                            break;
                        case 'y':
                            e.preventDefault();
                            this.redo();
                            break;
                        case 'a':
                            e.preventDefault();
                            this.selectAll();
                            break;
                        case 'c':
                            e.preventDefault();
                            this.copy();
                            break;
                        case 'v':
                            e.preventDefault();
                            this.paste();
                            break;
                        case 'x':
                            e.preventDefault();
                            this.cut();
                            break;
                    }
                } else {
                    // Tool shortcuts
                    switch(e.key.toLowerCase()) {
                        case 'v':
                            this.selectTool('select');
                            break;
                        case 'b':
                            this.selectTool('brush');
                            break;
                        case 'e':
                            this.selectTool('eraser');
                            break;
                        case 't':
                            this.selectTool('text');
                            break;
                        case 'u':
                            this.selectTool('shape');
                            break;
                        case 'i':
                            this.selectTool('eyedropper');
                            break;
                        case 'w':
                            this.selectTool('smartSelection');
                            break;
                        case 'o':
                            this.selectTool('objectDetection');
                            break;
                        case 'q':
                            this.selectTool('qualityAnalysis');
                            break;
                        case 'f':
                            this.selectTool('faceDetection');
                            break;
                        case 'e':
                            this.selectTool('emotionRecognition');
                            break;
                        case 'p':
                            this.selectTool('portraitEnhancement');
                            break;
                    }
                }
            }

            handleResize() {
                // Handle window resize
                this.updateStatusBar();
            }

            executeTool(tool, x, y, action) {
                if (!this.activeLayer || this.activeLayer.locked) return;
                
                switch(tool) {
                    case 'brush':
                        this.advancedBrushTool(x, y, action);
                        break;
                    case 'eraser':
                        this.advancedEraserTool(x, y, action);
                        break;
                    case 'select':
                        this.advancedSelectTool(x, y, action);
                        break;
                    case 'text':
                        this.advancedTextTool(x, y, action);
                        break;
                    case 'eyedropper':
                        this.eyedropperTool(x, y, action);
                        break;
                    case 'clone':
                        this.cloneStampTool(x, y, action);
                        break;
                    case 'healing':
                        this.healingTool(x, y, action);
                        break;
                    case 'gradient':
                        this.gradientTool(x, y, action);
                        break;
                    case 'shape':
                        this.shapeTool(x, y, action);
                        break;
                    case 'pen':
                        this.penTool(x, y, action);
                        break;
                    case 'move':
                        this.moveTool(x, y, action);
                        break;
                    case 'crop':
                        this.cropTool(x, y, action);
                        break;
                    case 'hand':
                        this.handTool(x, y, action);
                        break;
                    case 'zoom':
                        this.zoomTool(x, y, action);
                        break;
                    case 'smartSelection':
                        this.smartSelectionTool(x, y, action);
                        break;
                    case 'objectDetection':
                        this.objectDetectionTool(x, y, action);
                        break;
                    case 'qualityAnalysis':
                        this.qualityAnalysisTool(x, y, action);
                        break;
                    case 'faceDetection':
                        this.faceDetectionTool(x, y, action);
                        break;
                    case 'emotionRecognition':
                        this.emotionRecognitionTool(x, y, action);
                        break;
                    case 'portraitEnhancement':
                        this.portraitEnhancementTool(x, y, action);
                        break;
                }
            }

            advancedBrushTool(x, y, action) {
                const settings = this.toolSettings.brush;
                const ctx = this.activeLayer.ctx;
                
                ctx.globalAlpha = settings.opacity / 100;
                ctx.lineWidth = settings.size;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = this.foregroundColor;
                
                if (action === 'start') {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    this.lastX = x;
                    this.lastY = y;
                } else if (action === 'move') {
                    // Smooth brush strokes with interpolation
                    const dx = x - this.lastX;
                    const dy = y - this.lastY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const steps = Math.max(1, Math.floor(distance / (settings.size / 4)));
                    
                    for (let i = 1; i <= steps; i++) {
                        const t = i / steps;
                        const interpX = this.lastX + dx * t;
                        const interpY = this.lastY + dy * t;
                        ctx.lineTo(interpX, interpY);
                    }
                    ctx.stroke();
                    this.lastX = x;
                    this.lastY = y;
                }
                
                this.renderCanvas();
            }

            advancedEraserTool(x, y, action) {
                const settings = this.toolSettings.eraser;
                const ctx = this.activeLayer.ctx;
                
                ctx.globalCompositeOperation = 'destination-out';
                ctx.globalAlpha = settings.opacity / 100;
                ctx.lineWidth = settings.size;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                if (action === 'start') {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    this.lastX = x;
                    this.lastY = y;
                } else if (action === 'move') {
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    this.lastX = x;
                    this.lastY = y;
                }
                
                ctx.globalCompositeOperation = 'source-over';
                this.renderCanvas();
            }
            
            cloneStampTool(x, y, action) {
                const settings = this.toolSettings.clone;
                const ctx = this.activeLayer.ctx;
                
                if (action === 'start') {
                    // Set sample point
                    this.cloneSampleX = x;
                    this.cloneSampleY = y;
                    this.cloneOffsetX = 0;
                    this.cloneOffsetY = 0;
                } else if (action === 'move') {
                    // Calculate offset from sample point
                    this.cloneOffsetX = x - this.cloneSampleX;
                    this.cloneOffsetY = y - this.cloneSampleY;
                    
                    // Get pixel data from sample point
                    const sampleX = this.cloneSampleX + this.cloneOffsetX;
                    const sampleY = this.cloneSampleY + this.cloneOffsetY;
                    
                    if (sampleX >= 0 && sampleX < this.canvas.width && 
                        sampleY >= 0 && sampleY < this.canvas.height) {
                        const imageData = ctx.getImageData(sampleX, sampleY, settings.size, settings.size);
                        ctx.putImageData(imageData, x - settings.size/2, y - settings.size/2);
                    }
                }
                
                this.renderCanvas();
            }
            
            healingTool(x, y, action) {
                const settings = this.toolSettings.healing;
                
                if (action === 'start') {
                    if (settings.type === 'spot') {
                        // Content-aware spot healing
                        this.performContentAwareHealing(x, y, settings.size);
                    }
                }
                
                this.renderCanvas();
            }
            
            performContentAwareHealing(x, y, size) {
                // Enhanced content-aware healing using Rice MSC methodology
                const ctx = this.activeLayer.ctx;
                const radius = size / 2;
                
                // Get surrounding area for analysis
                const surroundingArea = ctx.getImageData(x - radius*2, y - radius*2, radius*4, radius*4);
                
                // Extract features from surrounding area (simplified version)
                const features = this.extractImageFeatures(surroundingArea);
                
                // Use morphological features for better healing
                const roundness = features.roundness || 0.5;
                const compactness = features.compactness || 1.0;
                
                // Adaptive healing based on features
                for (let i = 0; i < radius*2; i++) {
                    for (let j = 0; j < radius*2; j++) {
                        const distance = Math.sqrt(i*i + j*j);
                        if (distance <= radius) {
                            // Use roundness to determine blending pattern
                            const alpha = (1 - (distance / radius)) * roundness;
                            const targetX = x - radius + i;
                            const targetY = y - radius + j;
                            
                            if (targetX >= 0 && targetX < this.canvas.width && 
                                targetY >= 0 && targetY < this.canvas.height) {
                                
                                // Get surrounding pixel colors
                                const surroundingColors = this.getSurroundingColors(targetX, targetY, 3);
                                const avgColor = this.calculateAverageColor(surroundingColors);
                                
                                // Apply color correction based on compactness
                                const correctedColor = this.applyColorCorrection(avgColor, compactness);
                                
                                ctx.globalAlpha = alpha * 0.7;
                                ctx.fillStyle = correctedColor;
                                ctx.fillRect(targetX, targetY, 1, 1);
                            }
                        }
                    }
                }
                
                ctx.globalAlpha = 1.0;
            }
            
            extractImageFeatures(imageData) {
                // Simplified feature extraction based on Rice MSC methodology
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                // Calculate basic features
                let rSum = 0, gSum = 0, bSum = 0;
                let rSqSum = 0, gSqSum = 0, bSqSum = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    rSum += data[i];
                    gSum += data[i + 1];
                    bSum += data[i + 2];
                    rSqSum += data[i] * data[i];
                    gSqSum += data[i + 1] * data[i + 1];
                    bSqSum += data[i + 2] * data[i + 2];
                }
                
                const pixelCount = data.length / 4;
                const rMean = rSum / pixelCount;
                const gMean = gSum / pixelCount;
                const bMean = bSum / pixelCount;
                
                const rStd = Math.sqrt((rSqSum / pixelCount) - (rMean * rMean));
                const gStd = Math.sqrt((gSqSum / pixelCount) - (gMean * gMean));
                const bStd = Math.sqrt((bSqSum / pixelCount) - (bMean * bMean));
                
                // Calculate morphological features (simplified)
                const area = width * height;
                const perimeter = 2 * (width + height);
                const roundness = (4 * Math.PI * area) / (perimeter * perimeter);
                const compactness = (perimeter * perimeter) / (4 * Math.PI * area);
                
                return {
                    rMean, gMean, bMean,
                    rStd, gStd, bStd,
                    roundness,
                    compactness,
                    area,
                    perimeter
                };
            }
            
            getSurroundingColors(x, y, radius) {
                const colors = [];
                const ctx = this.activeLayer.ctx;
                
                for (let i = -radius; i <= radius; i++) {
                    for (let j = -radius; j <= radius; j++) {
                        const targetX = x + i;
                        const targetY = y + j;
                        
                        if (targetX >= 0 && targetX < this.canvas.width && 
                            targetY >= 0 && targetY < this.canvas.height) {
                            const pixelData = ctx.getImageData(targetX, targetY, 1, 1);
                            colors.push({
                                r: pixelData.data[0],
                                g: pixelData.data[1],
                                b: pixelData.data[2]
                            });
                        }
                    }
                }
                
                return colors;
            }
            
            calculateAverageColor(colors) {
                if (colors.length === 0) return '#000000';
                
                const rSum = colors.reduce((sum, c) => sum + c.r, 0);
                const gSum = colors.reduce((sum, c) => sum + c.g, 0);
                const bSum = colors.reduce((sum, c) => sum + c.b, 0);
                
                const r = Math.round(rSum / colors.length);
                const g = Math.round(gSum / colors.length);
                const b = Math.round(bSum / colors.length);
                
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            applyColorCorrection(color, compactness) {
                // Apply color correction based on compactness feature
                const rgb = color.match(/\d+/g).map(Number);
                
                // Adjust based on compactness (simplified color space transformation)
                const factor = Math.min(compactness / 2, 1.5);
                
                const r = Math.min(255, Math.round(rgb[0] * factor));
                const g = Math.min(255, Math.round(rgb[1] * factor));
                const b = Math.min(255, Math.round(rgb[2] * factor));
                
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            gradientTool(x, y, action) {
                if (action === 'start') {
                    this.gradientStartX = x;
                    this.gradientStartY = y;
                } else if (action === 'move') {
                    const ctx = this.activeLayer.ctx;
                    const gradient = ctx.createLinearGradient(
                        this.gradientStartX, this.gradientStartY, x, y
                    );
                    gradient.addColorStop(0, this.foregroundColor);
                    gradient.addColorStop(1, this.backgroundColor);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.renderCanvas();
                }
            }
            
            shapeTool(x, y, action) {
                if (action === 'start') {
                    this.shapeStartX = x;
                    this.shapeStartY = y;
                } else if (action === 'move') {
                    const ctx = this.activeLayer.ctx;
                    const width = x - this.shapeStartX;
                    const height = y - this.shapeStartY;
                    
                    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.renderCanvas();
                    
                    // Draw preview shape
                    ctx.strokeStyle = this.foregroundColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.shapeStartX, this.shapeStartY, width, height);
                }
            }
            
            penTool(x, y, action) {
                if (action === 'start') {
                    if (!this.penPath) {
                        this.penPath = new Path2D();
                        this.penPath.moveTo(x, y);
                    } else {
                        this.penPath.lineTo(x, y);
                    }
                } else if (action === 'move') {
                    // Show preview line
                    const ctx = this.activeLayer.ctx;
                    ctx.strokeStyle = this.foregroundColor;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.lastPenX || x, this.lastPenY || y);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                }
                
                this.lastPenX = x;
                this.lastPenY = y;
            }
            
            moveTool(x, y, action) {
                if (action === 'start') {
                    this.moveStartX = x;
                    this.moveStartY = y;
                } else if (action === 'move') {
                    const dx = x - this.moveStartX;
                    const dy = y - this.moveStartY;
                    
                    // Move selected layer or content
                    if (this.selection) {
                        this.moveSelection(dx, dy);
                    }
                }
            }
            
            cropTool(x, y, action) {
                if (action === 'start') {
                    this.cropStartX = x;
                    this.cropStartY = y;
                } else if (action === 'move') {
                    // Show crop preview
                    const ctx = this.ctx;
                    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.renderCanvas();
                    
                    const width = x - this.cropStartX;
                    const height = y - this.cropStartY;
                    
                    // Darken outside crop area
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    ctx.clearRect(this.cropStartX, this.cropStartY, width, height);
                    
                    // Draw crop border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.cropStartX, this.cropStartY, width, height);
                }
            }
            
            handTool(x, y, action) {
                if (action === 'start') {
                    this.handStartX = x;
                    this.handStartY = y;
                } else if (action === 'move') {
                    const dx = x - this.handStartX;
                    const dy = y - this.handStartY;
                    
                    this.offsetX += dx;
                    this.offsetY += dy;
                    this.updateCanvasTransform();
                    
                    this.handStartX = x;
                    this.handStartY = y;
                }
            }
            
            zoomTool(x, y, action) {
                if (action === 'start') {
                    this.zoom *= 1.2;
                    this.updateZoom();
                }
            }
            
            smartSelectionTool(x, y, action) {
                if (action === 'start') {
                    this.showNotification('Smart Selection: Analyzing image features...');
                    
                    // Get image data around click point
                    const radius = 50;
                    const imageData = this.ctx.getImageData(
                        Math.max(0, x - radius), 
                        Math.max(0, y - radius), 
                        Math.min(radius * 2, this.canvas.width - x + radius),
                        Math.min(radius * 2, this.canvas.height - y + radius)
                    );
                    
                    // Extract features using Rice MSC methodology
                    const features = this.extractImageFeatures(imageData);
                    
                    // Create smart selection based on features
                    this.createSmartSelection(x, y, features);
                    
                    this.showNotification(`Smart Selection: Roundness=${features.roundness.toFixed(2)}, Compactness=${features.compactness.toFixed(2)}`);
                }
            }
            
            objectDetectionTool(x, y, action) {
                if (action === 'start') {
                    this.showNotification('Object Detection: Analyzing objects...');
                    
                    // Detect objects in the image
                    const objects = this.detectObjects();
                    
                    // Highlight detected objects
                    this.highlightObjects(objects);
                    
                    this.showNotification(`Object Detection: Found ${objects.length} objects`);
                }
            }
            
            qualityAnalysisTool(x, y, action) {
                if (action === 'start') {
                    this.showNotification('Quality Analysis: Analyzing image quality...');
                    
                    // Get full image data
                    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Analyze quality using Rice MSC methodology
                    const quality = this.analyzeImageQuality(imageData);
                    
                    // Display quality report
                    this.displayQualityReport(quality);
                    
                    this.showNotification(`Quality Analysis: ${quality.grade} (${quality.score}/100)`);
                }
            }
            
            createSmartSelection(x, y, features) {
                const ctx = this.ctx;
                const radius = Math.max(20, features.roundness * 50);
                
                // Create selection based on morphological features
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                // Use roundness to determine selection shape
                if (features.roundness > 0.7) {
                    // Circular selection for round objects
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    ctx.stroke();
                } else {
                    // Rectangular selection for other objects
                    const size = radius * (1 + features.compactness);
                    ctx.strokeRect(x - size/2, y - size/2, size, size);
                }
                
                ctx.setLineDash([]);
            }
            
            detectObjects() {
                const objects = [];
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                
                // Simplified object detection using feature analysis
                const blockSize = 50;
                const blocksX = Math.floor(this.canvas.width / blockSize);
                const blocksY = Math.floor(this.canvas.height / blockSize);
                
                for (let bx = 0; bx < blocksX; bx++) {
                    for (let by = 0; by < blocksY; by++) {
                        const x = bx * blockSize;
                        const y = by * blockSize;
                        
                        const blockData = this.ctx.getImageData(x, y, blockSize, blockSize);
                        const features = this.extractImageFeatures(blockData);
                        
                        // Detect objects based on feature thresholds
                        if (features.roundness > 0.3 && features.compactness < 2.0) {
                            objects.push({
                                x: x + blockSize/2,
                                y: y + blockSize/2,
                                width: blockSize,
                                height: blockSize,
                                features: features,
                                confidence: features.roundness * (1 / features.compactness)
                            });
                        }
                    }
                }
                
                return objects;
            }
            
            highlightObjects(objects) {
                const ctx = this.ctx;
                
                objects.forEach((obj, index) => {
                    // Color code based on confidence
                    const confidence = obj.confidence;
                    const color = confidence > 0.7 ? '#00ff00' : 
                                 confidence > 0.5 ? '#ffff00' : '#ff0000';
                    
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obj.x - obj.width/2, obj.y - obj.height/2, obj.width, obj.height);
                    
                    // Add confidence label
                    ctx.fillStyle = color;
                    ctx.font = '12px Arial';
                    ctx.fillText(`${(confidence * 100).toFixed(0)}%`, 
                                obj.x - obj.width/2, obj.y - obj.height/2 - 5);
                });
            }
            
            analyzeImageQuality(imageData) {
                const features = this.extractImageFeatures(imageData);
                
                // Calculate quality score based on Rice MSC methodology
                let score = 0;
                
                // Roundness contribution (0-25 points)
                score += Math.min(25, features.roundness * 25);
                
                // Compactness contribution (0-25 points)
                score += Math.min(25, (1 / features.compactness) * 25);
                
                // Color distribution contribution (0-25 points)
                const colorVariance = (features.rStd + features.gStd + features.bStd) / 3;
                score += Math.min(25, colorVariance / 2);
                
                // Contrast contribution (0-25 points)
                const contrast = Math.max(features.rStd, features.gStd, features.bStd);
                score += Math.min(25, contrast / 2);
                
                // Determine grade
                let grade = 'Poor';
                if (score >= 80) grade = 'Excellent';
                else if (score >= 60) grade = 'Good';
                else if (score >= 40) grade = 'Fair';
                
                return {
                    score: Math.round(score),
                    grade: grade,
                    features: features,
                    recommendations: this.getQualityRecommendations(features)
                };
            }
            
            getQualityRecommendations(features) {
                const recommendations = [];
                
                if (features.roundness < 0.3) {
                    recommendations.push('Low roundness detected - consider smoothing');
                }
                
                if (features.compactness > 2.0) {
                    recommendations.push('High compactness - consider shape optimization');
                }
                
                if (features.rStd < 20) {
                    recommendations.push('Low contrast detected - consider enhancement');
                }
                
                return recommendations;
            }
            
            displayQualityReport(quality) {
                // Create quality report modal
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                
                modal.innerHTML = `
                    <div class="modal-content" style="width: 500px;">
                        <div class="modal-header">
                            <div class="modal-title">Image Quality Analysis</div>
                            <div class="close" onclick="this.parentElement.parentElement.parentElement.style.display='none'">&times;</div>
                        </div>
                        <div class="modal-body">
                            <h3>Quality Score: ${quality.score}/100 (${quality.grade})</h3>
                            <div style="margin: 20px 0;">
                                <h4>Feature Analysis:</h4>
                                <p>Roundness: ${quality.features.roundness.toFixed(3)}</p>
                                <p>Compactness: ${quality.features.compactness.toFixed(3)}</p>
                                <p>Color Variance: ${((quality.features.rStd + quality.features.gStd + quality.features.bStd) / 3).toFixed(1)}</p>
                                <p>Contrast: ${Math.max(quality.features.rStd, quality.features.gStd, quality.features.bStd).toFixed(1)}</p>
                            </div>
                            <div style="margin: 20px 0;">
                                <h4>Recommendations:</h4>
                                <ul>
                                    ${quality.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                                </ul>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-primary" onclick="this.parentElement.parentElement.parentElement.style.display='none'">Close</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
            }
            
            faceDetectionTool(x, y, action) {
                if (action === 'start') {
                    this.showNotification('Face Detection: Analyzing image for faces...');
                    
                    // Detect faces using Human Faces dataset methodology
                    const faces = this.detectFaces();
                    
                    // Highlight detected faces
                    this.highlightFaces(faces);
                    
                    this.showNotification(`Face Detection: Found ${faces.length} faces`);
                }
            }
            
            emotionRecognitionTool(x, y, action) {
                if (action === 'start') {
                    this.showNotification('Emotion Recognition: Analyzing facial expressions...');
                    
                    // Detect faces and analyze emotions
                    const faces = this.detectFaces();
                    const emotions = this.analyzeEmotions(faces);
                    
                    // Display emotion analysis
                    this.displayEmotionAnalysis(emotions);
                    
                    this.showNotification(`Emotion Recognition: Analyzed ${emotions.length} faces`);
                }
            }
            
            portraitEnhancementTool(x, y, action) {
                if (action === 'start') {
                    this.showNotification('Portrait Enhancement: Enhancing face quality...');
                    
                    // Detect faces and enhance them
                    const faces = this.detectFaces();
                    const enhanced = this.enhanceFaces(faces);
                    
                    // Apply enhancements to canvas
                    this.applyFaceEnhancements(enhanced);
                    
                    this.showNotification(`Portrait Enhancement: Enhanced ${enhanced.length} faces`);
                }
            }
            
            detectFaces() {
                const faces = [];
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                
                // Simplified face detection using feature analysis
                const blockSize = 80;
                const blocksX = Math.floor(this.canvas.width / blockSize);
                const blocksY = Math.floor(this.canvas.height / blockSize);
                
                for (let bx = 0; bx < blocksX; bx++) {
                    for (let by = 0; by < blocksY; by++) {
                        const x = bx * blockSize;
                        const y = by * blockSize;
                        
                        const blockData = this.ctx.getImageData(x, y, blockSize, blockSize);
                        const features = this.extractImageFeatures(blockData);
                        
                        // Face detection based on Human Faces dataset characteristics
                        if (this.isLikelyFace(features)) {
                            faces.push({
                                x: x + blockSize/2,
                                y: y + blockSize/2,
                                width: blockSize,
                                height: blockSize,
                                features: features,
                                confidence: this.calculateFaceConfidence(features)
                            });
                        }
                    }
                }
                
                return faces;
            }
            
            isLikelyFace(features) {
                // Face detection criteria based on Human Faces dataset
                const aspectRatio = features.area / (features.perimeter * features.perimeter);
                const symmetry = features.roundness;
                const texture = features.rStd + features.gStd + features.bStd;
                
                // Face-like characteristics
                return aspectRatio > 0.01 && 
                       symmetry > 0.3 && 
                       texture > 30 && 
                       texture < 100;
            }
            
            calculateFaceConfidence(features) {
                // Calculate confidence based on face-like characteristics
                const symmetry = features.roundness;
                const texture = (features.rStd + features.gStd + features.bStd) / 3;
                const aspectRatio = features.area / (features.perimeter * features.perimeter);
                
                let confidence = 0;
                confidence += symmetry * 0.4;
                confidence += Math.min(texture / 50, 1) * 0.3;
                confidence += Math.min(aspectRatio * 100, 1) * 0.3;
                
                return Math.min(confidence, 1);
            }
            
            highlightFaces(faces) {
                const ctx = this.ctx;
                
                faces.forEach((face, index) => {
                    const confidence = face.confidence;
                    const color = confidence > 0.7 ? '#00ff00' : 
                                 confidence > 0.5 ? '#ffff00' : '#ff0000';
                    
                    // Draw face bounding box
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(face.x - face.width/2, face.y - face.height/2, face.width, face.height);
                    
                    // Add face label
                    ctx.fillStyle = color;
                    ctx.font = '14px Arial';
                    ctx.fillText(`Face ${index + 1} (${(confidence * 100).toFixed(0)}%)`, 
                                face.x - face.width/2, face.y - face.height/2 - 10);
                    
                    // Draw face landmarks
                    this.drawFaceLandmarks(face);
                });
            }
            
            drawFaceLandmarks(face) {
                const ctx = this.ctx;
                ctx.fillStyle = '#00ffff';
                ctx.strokeStyle = '#00ffff';
                
                // Simplified facial landmarks
                const centerX = face.x;
                const centerY = face.y;
                const size = Math.min(face.width, face.height) / 4;
                
                // Eyes
                ctx.beginPath();
                ctx.arc(centerX - size, centerY - size/2, 3, 0, 2 * Math.PI);
                ctx.arc(centerX + size, centerY - size/2, 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // Nose
                ctx.beginPath();
                ctx.arc(centerX, centerY, 2, 0, 2 * Math.PI);
                ctx.fill();
                
                // Mouth
                ctx.beginPath();
                ctx.arc(centerX, centerY + size, size/2, 0, Math.PI);
                ctx.stroke();
            }
            
            analyzeEmotions(faces) {
                const emotions = [];
                
                faces.forEach(face => {
                    const emotion = this.recognizeEmotion(face.features);
                    emotions.push({
                        face: face,
                        emotion: emotion
                    });
                });
                
                return emotions;
            }
            
            recognizeEmotion(features) {
                // Simplified emotion recognition based on Human Faces dataset
                const brightness = features.rMean + features.gMean + features.bMean;
                const contrast = features.rStd + features.gStd + features.bStd;
                const symmetry = features.roundness;
                
                // Emotion classification
                if (brightness > 400 && contrast > 50) {
                    return { emotion: 'happy', confidence: 0.8, intensity: 0.9 };
                } else if (brightness < 200 && contrast < 30) {
                    return { emotion: 'sad', confidence: 0.7, intensity: 0.6 };
                } else if (contrast > 80) {
                    return { emotion: 'surprised', confidence: 0.6, intensity: 0.7 };
                } else if (symmetry < 0.4) {
                    return { emotion: 'angry', confidence: 0.5, intensity: 0.5 };
                } else {
                    return { emotion: 'neutral', confidence: 0.6, intensity: 0.4 };
                }
            }
            
            displayEmotionAnalysis(emotions) {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'block';
                
                const emotionSummary = this.generateEmotionSummary(emotions);
                
                modal.innerHTML = `
                    <div class="modal-content" style="width: 600px;">
                        <div class="modal-header">
                            <div class="modal-title">Emotion Recognition Analysis</div>
                            <div class="close" onclick="this.parentElement.parentElement.parentElement.style.display='none'">&times;</div>
                        </div>
                        <div class="modal-body">
                            <h3>Analysis Summary</h3>
                            <p>Total Faces Analyzed: ${emotions.length}</p>
                            <p>Dominant Emotion: ${emotionSummary.dominant}</p>
                            <p>Average Confidence: ${(emotionSummary.avgConfidence * 100).toFixed(1)}%</p>
                            
                            <div style="margin: 20px 0;">
                                <h4>Emotion Distribution:</h4>
                                <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                                    ${Object.entries(emotionSummary.distribution).map(([emotion, count]) => 
                                        `<div style="background: #f0f0f0; padding: 5px 10px; border-radius: 15px;">
                                            ${emotion}: ${count}
                                        </div>`
                                    ).join('')}
                                </div>
                            </div>
                            
                            <div style="margin: 20px 0;">
                                <h4>Individual Face Analysis:</h4>
                                ${emotions.map((item, index) => `
                                    <div style="border: 1px solid #ddd; padding: 10px; margin: 5px 0; border-radius: 5px;">
                                        <strong>Face ${index + 1}</strong>: ${item.emotion.emotion} 
                                        (${(item.emotion.confidence * 100).toFixed(0)}% confidence)
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-primary" onclick="this.parentElement.parentElement.parentElement.style.display='none'">Close</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
            }
            
            generateEmotionSummary(emotions) {
                const emotionCounts = {};
                let totalConfidence = 0;
                
                emotions.forEach(item => {
                    const emotion = item.emotion.emotion;
                    emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                    totalConfidence += item.emotion.confidence;
                });
                
                const dominant = Object.keys(emotionCounts).reduce((a, b) => 
                    emotionCounts[a] > emotionCounts[b] ? a : b, 'neutral');
                
                return {
                    dominant: dominant,
                    distribution: emotionCounts,
                    avgConfidence: emotions.length > 0 ? totalConfidence / emotions.length : 0
                };
            }
            
            enhanceFaces(faces) {
                const enhanced = [];
                
                faces.forEach(face => {
                    const enhancedFace = this.enhanceSingleFace(face);
                    enhanced.push(enhancedFace);
                });
                
                return enhanced;
            }
            
            enhanceSingleFace(face) {
                // Get face region
                const x = face.x - face.width/2;
                const y = face.y - face.height/2;
                const faceData = this.ctx.getImageData(x, y, face.width, face.height);
                
                // Apply enhancements based on Human Faces dataset insights
                const enhanced = this.applyFaceEnhancements(faceData, face.features);
                
                return {
                    original: face,
                    enhanced: enhanced,
                    region: { x, y, width: face.width, height: face.height }
                };
            }
            
            applyFaceEnhancements(faceData, features) {
                const data = faceData.data;
                const enhanced = new Uint8ClampedArray(data);
                
                // Brightness enhancement
                if (features.rMean < 100) {
                    for (let i = 0; i < data.length; i += 4) {
                        enhanced[i] = Math.min(255, data[i] * 1.2);     // Red
                        enhanced[i + 1] = Math.min(255, data[i + 1] * 1.2); // Green
                        enhanced[i + 2] = Math.min(255, data[i + 2] * 1.2); // Blue
                    }
                }
                
                // Contrast enhancement
                if (features.rStd < 30) {
                    const factor = 1.3;
                    for (let i = 0; i < data.length; i += 4) {
                        enhanced[i] = Math.min(255, Math.max(0, (data[i] - 128) * factor + 128));
                        enhanced[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * factor + 128));
                        enhanced[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * factor + 128));
                    }
                }
                
                // Skin tone enhancement
                const avgSkinTone = (features.rMean + features.gMean + features.bMean) / 3;
                if (avgSkinTone > 100 && avgSkinTone < 200) {
                    // Warm up skin tones
                    for (let i = 0; i < data.length; i += 4) {
                        enhanced[i] = Math.min(255, data[i] * 1.1);     // Increase red
                        enhanced[i + 1] = Math.min(255, data[i + 1] * 1.05); // Slight green increase
                        enhanced[i + 2] = Math.max(0, data[i + 2] * 0.95);   // Reduce blue
                    }
                }
                
                return new ImageData(enhanced, faceData.width, faceData.height);
            }
            
            applyFaceEnhancements(enhanced) {
                enhanced.forEach(item => {
                    this.ctx.putImageData(item.enhanced, item.region.x, item.region.y);
                });
                
                this.renderCanvas();
            }
            
            renderCanvas() {
                // Clear main canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Render all visible layers
                this.layers.forEach(layer => {
                    if (layer.visible) {
                        this.ctx.globalAlpha = layer.opacity / 100;
                        this.ctx.globalCompositeOperation = layer.blendMode;
                        this.ctx.drawImage(layer.canvas, 0, 0);
                    }
                });
                
                // Reset global settings
                this.ctx.globalAlpha = 1.0;
                this.ctx.globalCompositeOperation = 'source-over';
            }
            
            updateCanvasTransform() {
                this.canvas.style.transform = `translate(${this.offsetX}px, ${this.offsetY}px) scale(${this.zoom})`;
            }

            selectTool(x, y, action) {
                // Selection tool implementation
                if (action === 'start') {
                    this.selectionStartX = x;
                    this.selectionStartY = y;
                } else if (action === 'move') {
                    // Draw selection rectangle
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.putImageData(this.getLastState(), 0, 0);
                    
                    this.ctx.strokeStyle = '#007bff';
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeRect(
                        this.selectionStartX,
                        this.selectionStartY,
                        x - this.selectionStartX,
                        y - this.selectionStartY
                    );
                    this.ctx.setLineDash([]);
                }
            }

            textTool(x, y, action) {
                if (action === 'start') {
                    const text = prompt('Enter text:');
                    if (text) {
                        this.ctx.font = '16px Arial';
                        this.ctx.fillStyle = document.getElementById('colorPicker').value;
                        this.ctx.fillText(text, x, y);
                    }
                }
            }

            eyedropperTool(x, y, action) {
                if (action === 'start') {
                    const imageData = this.ctx.getImageData(x, y, 1, 1);
                    const data = imageData.data;
                    const color = `#${data[0].toString(16).padStart(2, '0')}${data[1].toString(16).padStart(2, '0')}${data[2].toString(16).padStart(2, '0')}`;
                    document.getElementById('colorPicker').value = color;
                    this.selectTool('select');
                }
            }

            selectTool(toolName) {
                this.currentTool = toolName;
                const currentToolElement = document.getElementById('currentTool');
                if (currentToolElement) {
                    currentToolElement.textContent = toolName.charAt(0).toUpperCase() + toolName.slice(1);
                }
                
                // Update tool buttons
                document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
                const toolButton = document.getElementById(toolName + 'Tool');
                if (toolButton) {
                    toolButton.classList.add('active');
                }
                
                this.showNotification(`Switched to ${toolName} tool`);
            }

            updateColor() {
                const color = document.getElementById('colorPicker').value;
                this.ctx.strokeStyle = color;
                this.ctx.fillStyle = color;
            }

            updateSize() {
                const size = document.getElementById('sizeSlider').value;
                document.getElementById('sizeValue').textContent = size;
                document.getElementById('toolSize').textContent = size + 'px';
                this.toolSettings.brush.size = parseInt(size);
                this.toolSettings.eraser.size = parseInt(size);
                this.toolSettings.clone.size = parseInt(size);
                this.toolSettings.healing.size = parseInt(size);
            }
            
            updateOpacity() {
                const opacity = document.getElementById('opacitySlider').value;
                document.getElementById('opacityValue').textContent = opacity + '%';
                this.toolSettings.brush.opacity = parseInt(opacity);
                this.toolSettings.eraser.opacity = parseInt(opacity);
                this.toolSettings.clone.opacity = parseInt(opacity);
            }
            
            updateFlow() {
                const flow = document.getElementById('flowSlider').value;
                document.getElementById('flowValue').textContent = flow + '%';
                this.toolSettings.brush.flow = parseInt(flow);
            }

            saveState() {
                this.historyIndex++;
                if (this.historyIndex < this.history.length) {
                    this.history = this.history.slice(0, this.historyIndex);
                }
                this.history.push(this.canvas.toDataURL());
            }

            getLastState() {
                if (this.historyIndex > 0) {
                    const img = new Image();
                    img.src = this.history[this.historyIndex - 1];
                    return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                }
                return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.loadState();
                    this.showNotification('Undo operation performed');
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.loadState();
                    this.showNotification('Redo operation performed');
                }
            }

            loadState() {
                const img = new Image();
                img.onload = () => {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.drawImage(img, 0, 0);
                };
                img.src = this.history[this.historyIndex];
            }

            newFile() {
                showModal('newFileModal');
            }

            openFile() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                this.canvas.width = img.width;
                                this.canvas.height = img.height;
                                this.ctx.drawImage(img, 0, 0);
                                this.saveState();
                                this.showNotification('File opened successfully');
                            };
                            img.src = e.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                };
                input.click();
            }

            saveFile() {
                const link = document.createElement('a');
                link.download = 'graphics-app-' + Date.now() + '.png';
                link.href = this.canvas.toDataURL();
                link.click();
                this.showNotification('File saved successfully');
            }

            saveAsFile() {
                this.saveFile();
            }

            exportPNG() {
                this.saveFile();
            }

            exportJPG() {
                const link = document.createElement('a');
                link.download = 'graphics-app-' + Date.now() + '.jpg';
                link.href = this.canvas.toDataURL('image/jpeg', 0.9);
                link.click();
                this.showNotification('Exported as JPG');
            }

            exportPDF() {
                this.showNotification('PDF export coming soon');
            }

            selectAll() {
                this.showNotification('Select All - coming soon');
            }

            copy() {
                this.showNotification('Copy - coming soon');
            }

            paste() {
                this.showNotification('Paste - coming soon');
            }

            cut() {
                this.showNotification('Cut - coming soon');
            }

            zoomIn() {
                this.zoom *= 1.2;
                this.updateZoom();
            }

            zoomOut() {
                this.zoom /= 1.2;
                this.updateZoom();
            }

            zoomFit() {
                this.zoom = 1;
                this.updateZoom();
            }

            updateZoom() {
                document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
                this.canvas.style.transform = `scale(${this.zoom})`;
            }

            showNotification(message) {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.style.display = 'block';
                
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }

            updateStatusBar() {
                document.querySelector('.status-item span').textContent = 'Ready';
            }
            
            updateLayersPanel() {
                const layersContent = document.getElementById('layers-content');
                layersContent.innerHTML = '';
                
                this.layers.forEach((layer, index) => {
                    const layerItem = document.createElement('div');
                    layerItem.className = 'sidebar-item';
                    if (layer === this.activeLayer) layerItem.classList.add('active');
                    
                    layerItem.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <span style="font-size: 10px;">${layer.visible ? 'üëÅÔ∏è' : '‚ùå'}</span>
                            <span style="font-size: 10px;">${layer.locked ? 'üîí' : 'üîì'}</span>
                            <span>${layer.name}</span>
                        </div>
                    `;
                    
                    layerItem.onclick = () => this.selectLayer(layer);
                    layersContent.appendChild(layerItem);
                });
            }
            
            selectLayer(layer) {
                this.activeLayer = layer;
                this.updateLayersPanel();
                this.updatePropertiesPanel();
            }
            
            updatePropertiesPanel() {
                if (this.activeLayer) {
                    document.querySelector('input[onchange="updateLayerOpacity(this.value)"]').value = this.activeLayer.opacity;
                    document.getElementById('opacityValue').textContent = this.activeLayer.opacity + '%';
                    document.querySelector('select[onchange="updateBlendMode(this.value)"]').value = this.activeLayer.blendMode;
                }
            }
            
            applyAdjustment(adjustment) {
                if (!this.activeLayer) return;
                
                const ctx = this.activeLayer.ctx;
                const imageData = ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                switch(adjustment.type) {
                    case 'brightness':
                        this.applyBrightnessContrast(data, adjustment.settings.brightness, adjustment.settings.contrast);
                        break;
                    case 'levels':
                        this.applyLevels(data, adjustment.settings);
                        break;
                    case 'hue':
                        this.applyHueSaturation(data, adjustment.settings);
                        break;
                    case 'invert':
                        this.applyInvert(data);
                        break;
                }
                
                ctx.putImageData(imageData, 0, 0);
                this.renderCanvas();
            }
            
            applyBrightnessContrast(data, brightness, contrast) {
                const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
                
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = factor * (data[i] - 128) + 128 + brightness;     // Red
                    data[i + 1] = factor * (data[i + 1] - 128) + 128 + brightness; // Green
                    data[i + 2] = factor * (data[i + 2] - 128) + 128 + brightness; // Blue
                    
                    data[i] = Math.max(0, Math.min(255, data[i]));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1]));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2]));
                }
            }
            
            applyLevels(data, settings) {
                const inputMin = settings.input[0];
                const inputMax = settings.input[2];
                const outputMin = settings.output[0];
                const outputMax = settings.output[2];
                
                for (let i = 0; i < data.length; i += 4) {
                    for (let j = 0; j < 3; j++) {
                        let value = data[i + j];
                        value = ((value - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin;
                        data[i + j] = Math.max(0, Math.min(255, value));
                    }
                }
            }
            
            applyHueSaturation(data, settings) {
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Convert to HSL
                    const hsl = this.rgbToHsl(r, g, b);
                    
                    // Apply adjustments
                    hsl[0] = (hsl[0] + settings.hue) % 360;
                    hsl[1] = Math.max(0, Math.min(100, hsl[1] + settings.saturation));
                    hsl[2] = Math.max(0, Math.min(100, hsl[2] + settings.lightness));
                    
                    // Convert back to RGB
                    const rgb = this.hslToRgb(hsl[0], hsl[1], hsl[2]);
                    data[i] = rgb[0];
                    data[i + 1] = rgb[1];
                    data[i + 2] = rgb[2];
                }
            }
            
            applyInvert(data) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];     // Red
                    data[i + 1] = 255 - data[i + 1]; // Green
                    data[i + 2] = 255 - data[i + 2]; // Blue
                }
            }
            
            applyFilter(type) {
                if (!this.activeLayer) return;
                
                const ctx = this.activeLayer.ctx;
                const imageData = ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                switch(type) {
                    case 'blur':
                        this.applyBlurFilter(data);
                        break;
                    case 'sharpen':
                        this.applySharpenFilter(data);
                        break;
                    case 'emboss':
                        this.applyEmbossFilter(data);
                        break;
                    case 'edge':
                        this.applyEdgeFilter(data);
                        break;
                    case 'invert':
                        this.applyInvert(data);
                        break;
                }
                
                ctx.putImageData(imageData, 0, 0);
                this.renderCanvas();
            }
            
            applyBlurFilter(data) {
                // Simple box blur implementation
                const width = this.canvas.width;
                const height = this.canvas.height;
                const tempData = new Uint8ClampedArray(data);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        let r = 0, g = 0, b = 0;
                        
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                r += tempData[nIdx];
                                g += tempData[nIdx + 1];
                                b += tempData[nIdx + 2];
                            }
                        }
                        
                        data[idx] = r / 9;
                        data[idx + 1] = g / 9;
                        data[idx + 2] = b / 9;
                    }
                }
            }
            
            applySharpenFilter(data) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const tempData = new Uint8ClampedArray(data);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        let r = tempData[idx] * 5;
                        let g = tempData[idx + 1] * 5;
                        let b = tempData[idx + 2] * 5;
                        
                        // Subtract surrounding pixels
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                r -= tempData[nIdx];
                                g -= tempData[nIdx + 1];
                                b -= tempData[nIdx + 2];
                            }
                        }
                        
                        data[idx] = Math.max(0, Math.min(255, r));
                        data[idx + 1] = Math.max(0, Math.min(255, g));
                        data[idx + 2] = Math.max(0, Math.min(255, b));
                    }
                }
            }
            
            applyEmbossFilter(data) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const tempData = new Uint8ClampedArray(data);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        const nIdx = ((y - 1) * width + (x - 1)) * 4;
                        
                        let r = tempData[idx] - tempData[nIdx] + 128;
                        let g = tempData[idx + 1] - tempData[nIdx + 1] + 128;
                        let b = tempData[idx + 2] - tempData[nIdx + 2] + 128;
                        
                        data[idx] = Math.max(0, Math.min(255, r));
                        data[idx + 1] = Math.max(0, Math.min(255, g));
                        data[idx + 2] = Math.max(0, Math.min(255, b));
                    }
                }
            }
            
            applyEdgeFilter(data) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const tempData = new Uint8ClampedArray(data);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        let r = 0, g = 0, b = 0;
                        
                        // Sobel edge detection
                        const gx = [
                            [-1, 0, 1],
                            [-2, 0, 2],
                            [-1, 0, 1]
                        ];
                        const gy = [
                            [-1, -2, -1],
                            [0, 0, 0],
                            [1, 2, 1]
                        ];
                        
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                const weightX = gx[dy + 1][dx + 1];
                                const weightY = gy[dy + 1][dx + 1];
                                
                                r += tempData[nIdx] * weightX;
                                g += tempData[nIdx + 1] * weightX;
                                b += tempData[nIdx + 2] * weightX;
                            }
                        }
                        
                        const magnitude = Math.sqrt(r * r + g * g + b * b);
                        const edgeValue = Math.min(255, magnitude);
                        
                        data[idx] = edgeValue;
                        data[idx + 1] = edgeValue;
                        data[idx + 2] = edgeValue;
                    }
                }
            }
            
            rgbToHsl(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                
                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                
                return [h * 360, s * 100, l * 100];
            }
            
            hslToRgb(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;
                
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }
            
            moveSelection(dx, dy) {
                if (!this.selection) return;
                
                const ctx = this.activeLayer.ctx;
                const imageData = ctx.getImageData(
                    this.selection.x, this.selection.y, 
                    this.selection.width, this.selection.height
                );
                
                // Clear original area
                ctx.clearRect(this.selection.x, this.selection.y, 
                             this.selection.width, this.selection.height);
                
                // Paste at new location
                ctx.putImageData(imageData, 
                                this.selection.x + dx, this.selection.y + dy);
                
                this.selection.x += dx;
                this.selection.y += dy;
                this.renderCanvas();
            }
        }

        // Global Functions
        function showModal(modalId) {
            document.getElementById(modalId).style.display = 'block';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        function toggleSection(sectionName) {
            const content = document.getElementById(sectionName + '-content');
            const toggle = document.getElementById(sectionName + '-toggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        function hideContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
            document.removeEventListener('click', hideContextMenu);
        }

        function showHelp() {
            alert('Help documentation coming soon!');
        }

        function showShortcuts() {
            showModal('shortcutsModal');
        }

        function showAbout() {
            alert('Fundamental Graphics Application v1.0\n\nA professional graphics application with core computer and office application skills.');
        }

        function createNewFile() {
            const width = parseInt(document.getElementById('newWidth').value);
            const height = parseInt(document.getElementById('newHeight').value);
            const bgColor = document.getElementById('newBgColor').value;
            
            window.graphicsApp.canvas.width = width;
            window.graphicsApp.canvas.height = height;
            window.graphicsApp.ctx.fillStyle = bgColor;
            window.graphicsApp.ctx.fillRect(0, 0, width, height);
            window.graphicsApp.saveState();
            
            closeModal('newFileModal');
            window.graphicsApp.showNotification('New document created');
        }

        // Advanced Photoshop-Level Functions
        function updateLayerOpacity(value) {
            if (window.graphicsApp.activeLayer) {
                window.graphicsApp.activeLayer.opacity = parseInt(value);
                document.getElementById('opacityValue').textContent = value + '%';
                window.graphicsApp.renderCanvas();
            }
        }
        
        function updateBlendMode(mode) {
            if (window.graphicsApp.activeLayer) {
                window.graphicsApp.activeLayer.blendMode = mode;
                window.graphicsApp.renderCanvas();
            }
        }
        
        function toggleLayerLock() {
            if (window.graphicsApp.activeLayer) {
                window.graphicsApp.activeLayer.locked = !window.graphicsApp.activeLayer.locked;
                const btn = document.querySelector('button[onclick="toggleLayerLock()"]');
                btn.textContent = window.graphicsApp.activeLayer.locked ? 'üîì Unlock' : 'üîí Lock';
            }
        }
        
        function addAdjustment(type) {
            const adjustment = {
                type: type,
                id: 'adj_' + Date.now(),
                settings: getDefaultAdjustmentSettings(type)
            };
            
            window.graphicsApp.adjustments.push(adjustment);
            window.graphicsApp.applyAdjustment(adjustment);
            window.graphicsApp.showNotification(`${type} adjustment added`);
        }
        
        function getDefaultAdjustmentSettings(type) {
            switch(type) {
                case 'brightness':
                    return { brightness: 0, contrast: 0 };
                case 'levels':
                    return { input: [0, 128, 255], output: [0, 128, 255] };
                case 'curves':
                    return { points: [[0,0], [128,128], [255,255]] };
                case 'hue':
                    return { hue: 0, saturation: 0, lightness: 0 };
                case 'color-balance':
                    return { shadows: [0,0,0], midtones: [0,0,0], highlights: [0,0,0] };
                case 'black-white':
                    return { red: 40, yellow: 60, green: 40, cyan: 60, blue: 20, magenta: 80 };
                default:
                    return {};
            }
        }
        
        function applyFilter(type) {
            window.graphicsApp.applyFilter(type);
            window.graphicsApp.showNotification(`${type} filter applied`);
        }
        
        function createNewLayer() {
            const layer = {
                id: 'layer_' + Date.now(),
                name: 'Layer ' + (window.graphicsApp.layers.length),
                visible: true,
                locked: false,
                opacity: 100,
                blendMode: 'normal',
                canvas: document.createElement('canvas'),
                type: 'pixel'
            };
            
            layer.canvas.width = window.graphicsApp.canvas.width;
            layer.canvas.height = window.graphicsApp.canvas.height;
            layer.ctx = layer.canvas.getContext('2d');
            
            window.graphicsApp.layers.push(layer);
            window.graphicsApp.activeLayer = layer;
            window.graphicsApp.updateLayersPanel();
            window.graphicsApp.showNotification('New layer created');
        }
        
        function deleteLayer() {
            if (window.graphicsApp.activeLayer && window.graphicsApp.activeLayer.type !== 'background') {
                const index = window.graphicsApp.layers.indexOf(window.graphicsApp.activeLayer);
                window.graphicsApp.layers.splice(index, 1);
                window.graphicsApp.activeLayer = window.graphicsApp.layers[0];
                window.graphicsApp.updateLayersPanel();
                window.graphicsApp.renderCanvas();
                window.graphicsApp.showNotification('Layer deleted');
            }
        }
        
        function duplicateLayer() {
            if (window.graphicsApp.activeLayer) {
                const original = window.graphicsApp.activeLayer;
                const duplicate = {
                    id: 'layer_' + Date.now(),
                    name: original.name + ' Copy',
                    visible: original.visible,
                    locked: original.locked,
                    opacity: original.opacity,
                    blendMode: original.blendMode,
                    canvas: document.createElement('canvas'),
                    type: original.type
                };
                
                duplicate.canvas.width = original.canvas.width;
                duplicate.canvas.height = original.canvas.height;
                duplicate.ctx = duplicate.canvas.getContext('2d');
                duplicate.ctx.drawImage(original.canvas, 0, 0);
                
                window.graphicsApp.layers.push(duplicate);
                window.graphicsApp.activeLayer = duplicate;
                window.graphicsApp.updateLayersPanel();
                window.graphicsApp.showNotification('Layer duplicated');
            }
        }
        
        // Global Functions for UI Controls
        function updateSize() {
            window.graphicsApp.updateSize();
        }
        
        function updateOpacity() {
            window.graphicsApp.updateOpacity();
        }
        
        function updateFlow() {
            window.graphicsApp.updateFlow();
        }
        
        // Global function for tool selection
        function selectTool(toolName) {
            if (window.graphicsApp) {
                window.graphicsApp.selectTool(toolName);
            } else {
                console.error('Graphics app not initialized');
            }
        }
        
        // Test functionality function
        function testFunctionality() {
            if (window.graphicsApp) {
                console.log('Testing functionality...');
                
                // Test drawing on canvas
                const ctx = window.graphicsApp.ctx;
                if (ctx) {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(50, 50, 100, 100);
                    window.graphicsApp.showNotification('Test: Red square drawn on canvas!');
                }
                
                // Test tool selection
                window.graphicsApp.selectTool('brush');
                
                // Test AI features
                window.graphicsApp.showNotification('AI Features: Rice MSC + Human Faces datasets integrated!');
            } else {
                console.error('Graphics app not available for testing');
                alert('Graphics app not initialized. Please refresh the page.');
            }
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            window.graphicsApp = new AdvancedGraphicsApp();
            window.graphicsApp.showNotification('Enhanced Graphics Application with Rice MSC AI Features loaded!');
            
            // Debug: Check if app is initialized
            console.log('Graphics App initialized:', window.graphicsApp);
            console.log('Canvas element:', document.getElementById('canvas'));
            
            // Test basic functionality
            setTimeout(() => {
                if (window.graphicsApp) {
                    console.log('Testing basic functionality...');
                    window.graphicsApp.showNotification('Testing tools - click any tool button!');
                }
            }, 1000);
        });

        // Close modals when clicking outside
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        }
    </script>
</body>
</html> 